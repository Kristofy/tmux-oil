#!/usr/bin/env python3

import argparse
import os
import shlex
import subprocess
import tempfile
from dataclasses import dataclass

TMUX_WINDOW_DATA_FORMAT = "#{window_id};#{window_index};#{window_name}"

def edit_text(content: str = "", suffix: str = ".txt") -> str:
    editor = os.environ.get('EDITOR') or 'vi'
    editor = shlex.split(editor)

    with tempfile.NamedTemporaryFile(mode='w+', suffix=suffix, delete=False, encoding='utf-8') as tf:
        tf.write(content)
        tf.flush()
        temp_path = tf.name

    try:
        subprocess.run([*editor, temp_path], check=True)
        with open(temp_path, 'r', encoding='utf-8') as f:
            return f.read()
    except subprocess.CalledProcessError:
        # Editor exited with an error
        raise RuntimeError("Editor exited with an error")
    finally:
        os.unlink(temp_path)

@dataclass
class TmuxWindow:
    server_socket_path: str | None
    session_id: str
    window_id: str
    index: int
    name: str

    @staticmethod
    def parse_window_data(line: str) -> tuple[str, int, str]:
        window_id, window_index, window_name = line.strip().split(';', 2)
        return window_id, int(window_index), window_name

    @classmethod
    def from_session(cls, session_id: str, server_socket_path: str | None = None) -> list['TmuxWindow']:
        # tmux -S /tmp/tmux-1000/default list-windows -t "dev" -F "#{window_index} #{window_id} #{window_name}" > /dev/null
        socket_cmd = [] if server_socket_path is None else ["-S", server_socket_path]

        result = subprocess.check_output(
            ["tmux", *socket_cmd, "list-windows", "-t", session_id, "-F", TMUX_WINDOW_DATA_FORMAT],
            text=True,
        )

        return [
            TmuxWindow(server_socket_path, session_id, *cls.parse_window_data(line))
            for line in result.strip().split('\n')
        ]


@dataclass
class CreateEditKind:
    index: int
    name: str

@dataclass
class RenameEditKind:
    win: TmuxWindow
    name: str

@dataclass
class DeleteEditKind:
    win: TmuxWindow

@dataclass
class MoveEditKind:
    win: TmuxWindow
    target_index: int


class Plan:
    session_id: str
    steps: list[CreateEditKind | DeleteEditKind | MoveEditKind | RenameEditKind]
    initial_windows: list[TmuxWindow]

    def __init__(self, session_id: str, steps: list[CreateEditKind | DeleteEditKind | MoveEditKind | RenameEditKind], initial_windows: list[TmuxWindow]):
        self.session_id = session_id
        self.steps = steps
        self.initial_windows = initial_windows

    @classmethod
    def create_plan(cls, session_id: str, initial_windows: list[TmuxWindow], new_state: str) -> 'Plan':

        existing_indexes: dict[int, TmuxWindow] = { win.index: win for win in initial_windows }

        # Remove leading and trailing whitespaces
        lines = [line.strip() for line in new_state.split('\n')]
        # Remove comments, that begin with #, or empty lines
        lines = [line for line in lines if not line.startswith('#') and line != ""]
        # Parse lines, accepted cases

        ##############
        # id: name   # -> split at the first :, and id must be a number, name can be empty, the the space is optional
        # _: name    # -> split at the first :, and id must be a '_', name can be empty, the the space is optional, means a new window, that we have to figure out the index for
        ##############

        if len(lines) == 0:
            # Prompt user if they are sure, then kill session
            ans = input("You are about to delete all windows in the session. Are you sure? (y/N): ")
            if ans.lower() != 'y':
                exit(0)

            subprocess.run(
                ["tmux", "kill-session", "-t", session_id],
                check=True,
            )
            exit(0)


        target_windows: list[tuple[int, str]] = []
        for line in lines:
            if ':' not in line:
                raise RuntimeError(f"Invalid line: {line}, expected: \"id: name\" or \"_: name\"")

            index, name = line.split(':', 1)
            if index != '_' and not index.isdigit():
                raise RuntimeError(f"Invalid line: {line}, invalid index, expected: number or _")

            index = -1 if index == '_' else int(index)
            target_windows.append((index, name.strip()))

        # target windows cannot have duplicate indexes (excluding -1), and every index must have existed beforehand
        seen_indecies: set[int] = set()
        for (index, _) in target_windows:
            if index == -1:  # This is a new entry
                continue

            # Check for duplicates
            if index in seen_indecies:
                raise RuntimeError(f"Index: {index} appeared twice")
            seen_indecies.add(index)

            if index not in existing_indexes:
                raise RuntimeError(f"Index: {index} did not exist, use \"_: name\" to create a new window")

        remaining_indexes: dict[int, str] = {index: name for (index, name) in target_windows if index != -1}

        # Steps
        # 1. Delete
        # 3. Rename windows
        # 2. Create the correct order
        # 4. Create new


        steps: list[CreateEditKind | DeleteEditKind | MoveEditKind | RenameEditKind] = []
        # The final position of the created element is the index(?)
        base_index = min(initial_windows, key=lambda x: x.index).index

        # Delete
        # The index offset should at position i mean that an index in the initial windows at pos i, should be shifted down index_offset[i]
        index_offset: list[int] = [0] * len(initial_windows)
        for (index, win) in existing_indexes.items():
            if index not in remaining_indexes:
                steps.append(DeleteEditKind(win))
                index_offset[win.index - base_index] = 1

        for i in range(1, len(index_offset)):
            index_offset[i] += index_offset[i - 1]


        # Rename
        for (index, win) in existing_indexes.items():
            # rename if it still exists and the name is different
            if index in remaining_indexes and remaining_indexes[index] != win.name:
                steps.append(RenameEditKind(win, remaining_indexes[index]))

        # Reorder
        # its tricky, since we can only move from A to pos B, meaning that if A < B then all indexes bigger then A and smaller then B will shift down
        # since things are only shifted down, we can start on the top and assign everything from the furthest target, since it is always the biggest remaining
        # it will not change positions after

        new_order: list[TmuxWindow] = [win for win in initial_windows if win.index in remaining_indexes]
        # print(f"base index: {base_index}")
        # print(index_offset)
        # target_windows_order = [w for w in target_windows if w[0] != -1]
        # for new_index, (initial_old_index, _) in reversed(list(enumerate(target_windows_order))):
        #     old_index = initial_old_index - index_offset[initial_old_index - base_index] - base_index
        #     print(f"move: {old_index} -> {new_index}")
        #     # target_windows_order[old_index] = (initial_old_index, target_windows_order[old_index][1])
        #     new_order[new_index], new_order[old_index] = new_order[old_index], new_order[new_index]
        
        new_index_by_old_index: dict[int, int] = {old_index: i + base_index for i, (old_index, _) in enumerate([w for w in target_windows if w[0] != -1]) }
        new_order.sort(key=lambda win: new_index_by_old_index[win.index])

        indecies = [i + base_index for i in range(len(new_order))]
        for i, win in reversed(list(enumerate(new_order))):
            new_index = i + base_index
            old_index = win.index - index_offset[win.index - base_index]

            if old_index != indecies[i]:
                # 1 3 4 5 2 || op 3 -> 4 
                index = indecies.index(old_index)
                indecies.pop(index)
                steps.append(MoveEditKind(win, new_index))
            else:
                indecies.pop()

        # Create new
        for i, (index, name) in enumerate(target_windows):
            if index == -1:
                steps.append(CreateEditKind(i + base_index, name))

        return Plan(session_id, steps, initial_windows)


    def execute(self) -> None:
        windows = self.initial_windows.copy()
        base_index = windows[0].index

        def tmux_swap_and_shift(original_index: int, dest:int) -> None:
            src_index = next(i for i, win in enumerate(windows) if win.index == original_index)
            target_index = dest - base_index
            direction = 1 if dest > src_index else -1
            for index in range(src_index, target_index, direction):
                # tmux swap-window -s {session_name}:{src} -t {session_name}:{dest}
                subprocess.run([
                        "tmux", "swap-window",
                        "-s", f"{self.session_id}:{windows[index].window_id}",
                        "-t", f"{self.session_id}:{windows[index + direction].window_id}"
                    ],
                    check=True,
                )
                windows[index], windows[index + direction] = windows[index + direction], windows[index]

        for step in self.steps:
            match step:
                case DeleteEditKind(win):
                    subprocess.run(
                        ["tmux", "kill-window", "-t", f"{self.session_id}:{win.window_id}"],
                        check=True,
                    )
                case RenameEditKind(win, name):
                    subprocess.run(
                        ["tmux", "rename-window", "-t", f"{self.session_id}:{win.window_id}", name],
                        check=True,
                    )
                case MoveEditKind(win, target_index):
                    tmux_swap_and_shift(win.index, target_index)
                case CreateEditKind(index, name):
                    result = subprocess.check_output(
                        ["tmux", "new-window", "-t", f"{self.session_id}:", "-n", name, "-d", "-P", "-F", TMUX_WINDOW_DATA_FORMAT],
                        text=True,
                    )

                    win = TmuxWindow(None, self.session_id, *TmuxWindow.parse_window_data(result))
                    windows.append(win)
                    tmux_swap_and_shift(win.index, index)


def main(session_id: str):
    windows = TmuxWindow.from_session(session_id)
    buffer = ""
    buffer += "# Edit windows for session. Format: N: Title\n"
    buffer += "# Use _: Title to create new windows. Comments (#) and blank lines are ignored.\n"
    buffer += "\n"
    buffer += "\n".join(f"{w.index}: {w.name}" for w in windows)

    user_request = edit_text(buffer, ".tmux")
    if user_request is None:
        raise RuntimeError("Something went wrong opening the file")

    initial_active_window_id = subprocess.check_output(
        ["tmux", "display-message", "-p", "-t", session_id, "#{window_id}"],
        text=True,
    ).strip()

    plan = Plan.create_plan(session_id, windows, user_request)
    plan.execute()

    # activate the initial window
    subprocess.run(
        ["tmux", "select-window", "-t", f"{session_id}:{initial_active_window_id}"],
        check=True,
    )

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process a tmux session ID.")
    parser.add_argument("session_id", type=str, help="The tmux session ID (e.g., 1, 0:1, or my-session)")
    args = parser.parse_args()
    session_id = args.session_id
    main(session_id)
